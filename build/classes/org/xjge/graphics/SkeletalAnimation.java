package org.xjge.graphics;

import java.util.List;
import org.joml.Matrix4f;
import org.lwjgl.assimp.AIAnimation;

/**
 * Created: Jun 17, 2021
 * <br><br>
 * Skeletal animations utilize a series of interconnected bones (collectively 
 * known as an "Armature") to offset the vertex positions of a models mesh. 
 * More generally, the individual bones of the models armature are arranged 
 * into one or more {@link KeyFrame KeyFrames} which are then played in 
 * sequence to create the illusion of movement.
 * <p>
 * Because the structure of the armature is hierarchal, moving a single 
 * {@link Bone} will in turn effect each of its children equally. That is, if 
 * we move the femur bone of some bipedal model for instance, the shin, foot, 
 * and toes will follow- however the hip bone (parent to the femur) will remain 
 * stationary.
 * 
 * @author J Hoffman
 * @since  2.0.0
 */
class SkeletalAnimation {

    final float duration;
    private float frameTime;
    private float seekTime;
    
    final boolean transition;
    private boolean finished;
    
    final String name;
    final String nextAnim;
    private KeyFrame prevFrame;
    private final KeyFrame currFrame = new KeyFrame();
    private KeyFrame nextFrame;
    
    private final List<KeyFrame> frames;
    
    /**
     * Constructs a new skeletal animation using the animation data and 
     * keyframes provided.
     * 
     * @param aiAnimation the raw animation data as provided by Assimp
     * @param frames a collection of every {@link KeyFrame KeyFrame} that will 
     *               be used by this animation
     */
    SkeletalAnimation(AIAnimation aiAnimation, List<KeyFrame> frames) {
        duration    = (float) aiAnimation.mDuration();
        name        = parseName(aiAnimation.mName().dataString());
        this.frames = frames;
        transition  = false;
        nextAnim    = null;
    }
    
    /**
     * Overloaded variant of {@link SkeletalAnimation(AIAnimation, 
     * List(KeyFrame2))}. Used to construct short transition animations.
     * 
     * @param currAnim the animation currently playing
     * @param nextAnim the animation to play following this one
     * @param frames the keyframes automatically generated by the {@link Model} class
     */
    SkeletalAnimation(String currAnim, String nextAnim, List<KeyFrame> frames) {
        duration      = frames.size();
        name          = "Transition|" + currAnim + "->" + nextAnim;
        this.frames   = frames;
        transition    = true;
        this.nextAnim = nextAnim;
    }
    
    /**
     * Parses and formats a string from Assimp which represents the name of an
     * animation.
     * 
     * @param aiName the unaltered name of the model as it appears in the model file data
     * 
     * @return a human-readable string which can be used to identify the  animation
     */
    private String parseName(String aiName) {
        return (aiName.contains("Armature|")) ? aiName.substring(aiName.indexOf("|") + 1, aiName.length()) : aiName;
    }
    
    /**
     * Increments the animations sequence forward.
     * 
     * @param speed a non-negative number used to set the animations playback speed
     * @param loop  if true, animations will loop indefinitely until stopped
     * @param delta the time (in seconds) it took to complete a single game tick
     */
    private void step(float speed, boolean loop, double delta) {
        if(speed > 0) {
            frameTime += (speed + delta);
            seekTime  += (speed + delta);
        }
        
        if(frameTime > 1) frameTime %= 1;
        
        if(transition) finished = (seekTime >= duration - 2);
        
        if(seekTime > duration - 2) {
            if(loop) {
                seekTime %= duration;
            } else {
                frameTime = 0;
                seekTime  = duration;
            }
        }
    }
    
    /**
     * Finds the previous and next keyframes nearest to the animations current 
     * timestamp.
     */
    private void findNearestFrames() {
        prevFrame = frames.get(0);
        nextFrame = frames.get(0);
        
        for(int f = 0; f < frames.size(); f++) {
            nextFrame = frames.get(f);
            
            if(f > seekTime) {
                if(f == frames.size() - 1) nextFrame = frames.get(0);
                else break;
            }
            
            prevFrame = frames.get(f);
        }
    }
    
    /**
     * Obtains a value which indicates how close we are to completing the 
     * animations current {@link KeyFrame}.
     * 
     * @return a non-negative number (between 0 and 1) indicating the 
     *         progression of the animations current keyframe
     */
    float getFrameTime() {
        return frameTime;
    }
    
    /**
     * Obtains the number of keyframes this animation has.
     * 
     * @return the number of keyframes parsed from the file
     */
    int getFrameCount() {
        return frames.size();
    }
    
    /**
     * Obtains the current amount of time that's elapsed in the animation.
     * 
     * @return the seek time of the animation (in seconds)
     */
    float getSeekTime() {
        return seekTime;
    }
    
    /**
     * Checks whether an animation has finished playing.
     * 
     * @return true if the animation has completed a full cycle of all its keyframes
     */
    boolean getFinished() {
        return finished;
    }
    
    /**
     * Obtains the current keyframe an animation is using.
     * 
     * @return the animations current keyframe
     */
    KeyFrame getCurrFrame() {
        return currFrame;
    }
    
    /**
     * Returns the keyframe at the index specified.
     * 
     * @param index a value indicating the point in sequence to check
     * 
     * @return a keyframe object used by the animation
     */
    KeyFrame getFrame(int index) {
        return frames.get(index);
    }
    
    /**
     * Sets the time elapsed between the current {@link KeyFrame} and the next 
     * one in sequence.
     * 
     * @param frameTime a non-negative number (between 0 and 1) indicating the 
     *                  progression of the animations current keyframe
     */
    void setFrameTime(float frameTime) {
        if(frameTime > 1)      frameTime = 1;
        else if(frameTime < 0) frameTime = 0;
        
        this.frameTime = frameTime;
    }
    
    /**
     * Sets the current seek time of the animation. Similar in function to a 
     * slider on a video or movie that can be moved back and forth to change 
     * the current time/frame/scene.
     * 
     * @param seekTime a value to offset the animations current seek/elapsed time with
     */
    void setSeekTime(float seekTime) {
        this.seekTime = seekTime;
    }
    
    /**
     * Generates a new "intermediate frame" between the previous and next 
     * {@linkplain KeyFrame keyframes} in sequence.
     * <p>
     * More specifically, by linearly interpolating between the values of the 
     * two keyframes bone transformations, a new set of transformations will be 
     * produced dynamically, enabling animation playback speed to be altered 
     * freely with smooth results.
     * 
     * @param speed a non-negative number used to set the animations playback speed
     * @param loop if true, animations will loop indefinitely until stopped
     * @param delta the time (in seconds) it took to complete a single game tick
     */
    void genCurrFrame(float speed, boolean loop, double delta) {
        step(speed, loop, delta);
        findNearestFrames();
        
        for(int b = 0; b < Model.MAX_BONES; b++) {
            prevFrame.transforms.get(b).lerp(nextFrame.transforms.get(b), frameTime, currFrame.transforms.get(b));
        }
    }
    
    /**
     * Calculates a new matrix value representing a bone transformation 
     * between two animations that will act as part of a larger {@link KeyFrame}.
     * 
     * @param index the location in the collection to store this transformation at
     * 
     * @return a new matrix object used to store the calculated transform value
     */
    Matrix4f calcTransition(int index) {
        findNearestFrames();
        Matrix4f result = new Matrix4f();
        prevFrame.transforms.get(index).lerp(nextFrame.transforms.get(index), frameTime, result);
        
        return result;
    }
    
}